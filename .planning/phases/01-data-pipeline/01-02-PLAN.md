---
phase: 01-data-pipeline
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - scripts/classify-provisions.ts
autonomous: true
requirements:
  - PIPE-01
  - PIPE-02
  - PIPE-03
  - PIPE-04
  - PIPE-08

must_haves:
  truths:
    - "scripts/classify-provisions.ts exists and is a runnable TypeScript script"
    - "The script reads source files from public/data/ftc-files/ and skips already-classified files"
    - "The script classifies each provision using rule-based mapping first, LLM for affirmative_obligation"
    - "Tags are written into source files atomically (write to .tmp, validate, rename)"
    - "The script reports progress per-case to stdout so interrupted runs can be diagnosed"
    - "Case-level statutory_topics are derived as the union of all provision-level statutory_topics"
    - "No classification logic is embedded in browser code"
  artifacts:
    - path: "scripts/classify-provisions.ts"
      provides: "Classification agent script for tagging all 293 source files"
      min_lines: 150
      contains: "isAlreadyClassified"
    - path: "scripts/classify-provisions.ts"
      provides: "Safe atomic file write utility"
      contains: "writeJSONSafe"
    - path: "scripts/classify-provisions.ts"
      provides: "Rule-based remedy type mapping"
      contains: "CATEGORY_REMEDY_MAP"
  key_links:
    - from: "scripts/classify-provisions.ts"
      to: "src/types/ftc.ts"
      via: "import type"
      pattern: "import.*from.*src/types/ftc"
    - from: "scripts/classify-provisions.ts"
      to: "public/data/ftc-files/"
      via: "readFileSync / writeJSONSafe"
      pattern: "writeJSONSafe|renameSync"
---

<objective>
Write scripts/classify-provisions.ts — the one-time classification agent script that reads all 293 FTC case source files, adds statutory topic, practice area, remedy type, and industry sector tags, and writes them back into the source files.

Purpose: This script is the classification engine. It must be idempotent (safe to re-run), atomic in its file writes (no corruption risk), and clear about what signals drive each classification decision. It writes tags into source files so the build step reads pre-classified data — no classification logic ships to the browser (PIPE-08).

Output: scripts/classify-provisions.ts — a fully functional TypeScript script ready to be run as a supervised interactive classification session via Claude Code.
</objective>

<execution_context>
@C:/Users/rafst/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rafst/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/ftc.ts
@scripts/build-ftc-data.ts
@.planning/phases/01-data-pipeline/01-RESEARCH.md
@.planning/phases/01-data-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write classify-provisions.ts with rule-based remedy mapping and safe file I/O</name>
  <files>scripts/classify-provisions.ts</files>
  <action>
    Create scripts/classify-provisions.ts as a TypeScript script (runs via `npx tsx scripts/classify-provisions.ts`). Build it with the following components:

    **Imports:**
    - Node.js built-ins: fs (readFileSync, writeFileSync, renameSync, readdirSync), path (join, resolve)
    - Type imports from '../src/types/ftc.js': StatutoryTopic, PracticeArea, RemedyType, IndustrySector, ClassifiedProvision, ClassifiedCaseInfo

    **Constants (deterministic remedy mapping — no LLM needed for these):**
    ```
    CATEGORY_REMEDY_MAP: Record<string, RemedyType[]> = {
      assessment: ["Third-Party Assessment"],
      compliance_reporting: ["Compliance Monitoring"],
      monitoring: ["Compliance Monitoring"],
      recordkeeping: ["Recordkeeping"],
      acknowledgment: ["Recordkeeping"],
      duration: ["Other"],
    }
    ```
    For "prohibition" category: check title.toLowerCase() for "facial recognition" | "biometric ban" | "biometric" → ["Biometric Ban"]; for "algorithm" | "model destruction" | "algorithmic" → ["Algorithmic Destruction"]; otherwise → ["Prohibition"].
    For "affirmative_obligation": this requires LLM — return null from the rule-based function, signal that LLM judgment is needed.

    **Statutory topic extraction from legal_authority string (rule-based):**
    The legal_authority field contains statute names as text. Map these patterns:
    - Contains "COPPA" or "Children's Online Privacy Protection" → include "COPPA"
    - Contains "FCRA" or "Fair Credit Reporting" → include "FCRA"
    - Contains "GLBA" or "Gramm-Leach-Bliley" or "Financial Modernization" → include "GLBA"
    - Contains "Health Breach Notification" → include "Health Breach Notification"
    - Contains "CAN-SPAM" → include "CAN-SPAM"
    - Contains "TCPA" or "Telephone Consumer Protection" → include "TCPA"
    - Contains "Telemarketing Sales Rule" or "TSR" → include "TSR"
    - If none of the above match → include "Section 5 Only"

    **Safe file write (CRITICAL — prevents source file corruption):**
    ```typescript
    function writeJSONSafe(filePath: string, data: unknown): void {
      const tmp = filePath + '.tmp';
      const serialized = JSON.stringify(data, null, 2);
      JSON.parse(serialized); // throws if invalid — validates before writing
      writeFileSync(tmp, serialized, 'utf-8');
      renameSync(tmp, filePath);
    }
    ```

    **Idempotency check:**
    ```typescript
    function isAlreadyClassified(caseData: unknown): boolean {
      return (caseData as any)?.case_info?.statutory_topics !== undefined;
    }
    ```

    **Classification function for a single case (the core classification logic):**
    This function receives the full parsed case JSON object. It must:
    1. Extract statutory_topics from case_info.legal_authority using rule-based matching above
    2. For each provision in order.provisions:
       a. Determine remedy_types using CATEGORY_REMEDY_MAP; for affirmative_obligation, examine provision.title:
          - "civil penalty" | "monetary" | "judgment" → ["Monetary Penalty"]
          - "deletion" | "dispose" | "destroy" | "destruction of" → ["Data Deletion"]
          - "security program" | "information security" | "safeguard" → ["Comprehensive Security Program"]
          - "biometric" | "facial recognition" → ["Biometric Ban"]
          - "algorithm" | "model" → ["Algorithmic Destruction"]
          - anything else affirmative → ["Other"]
       b. Determine practice_areas using provision.title and provision.summary keywords:
          - Signals for "Data Security": "security program", "safeguard", "intrusion", "breach", "vulnerability", "encryption", "firewall", "penetration test", "third-party assessment", "information security"
          - Signals for "Privacy": ONLY if primary violation is misrepresentation of privacy policy — title/summary explicitly about "privacy policy", "privacy notice", "misrepresent" + "collect", "share" or "disclose" without "security" or specific statute
          - Signals for "Deceptive Design / Dark Patterns": "dark pattern", "pre-checked", "negative option", "cancellation", "unsubscribe", "opt-out", "deceptive design", "confusing interface"
          - Signals for "AI / Automated Decision-Making": "algorithm", "automated", "machine learning", "artificial intelligence", "AI", "model", "scoring"
          - Signals for "Surveillance": "track", "location", "geolocation", "biometric", "facial recognition", "monitoring without consent", "surveillance"
          - Signals for "Financial Practices": "credit", "loan", "debt", "payment", "billing", "financial"
          - Signals for "Telemarketing": "telemarketing", "robocall", "TSR", "telephone"
          - If no strong signal matches → ["Other"]
          A provision may have multiple practice areas. Check all.
       c. Determine provision-level statutory_topics: inherit from case-level statutory_topics (same case = same statutes apply), EXCEPT if provision title explicitly references a different statute, use that.
    3. Build case-level aggregations: statutory_topics = case-level rule-based result (as computed above); practice_areas = UNION of all provision-level practice_areas; industry_sectors = classify from case_info.business_description using:
       - "technology" | "software" | "app" | "platform" | "internet" | "online" | "data broker" | "adtech" → "Technology"
       - "health" | "medical" | "fitness" | "wellness" | "patient" | "clinical" → "Healthcare"
       - "bank" | "credit" | "financial" | "insurance" | "lending" | "mortgage" | "fintech" → "Financial Services"
       - "retail" | "e-commerce" | "store" | "shop" | "consumer product" → "Retail"
       - "telecom" | "wireless" | "carrier" | "phone" | "mobile" → "Telecom"
       - "education" | "school" | "student" | "learning" | "edtech" → "Education"
       - "social" | "social network" | "social media" → "Social Media"
       - Otherwise → "Other"
       Multiple sectors can match — include all matches.
    4. Return the classified case object with all tags written in.

    **Main loop:**
    ```typescript
    const DATA_DIR = path.resolve('public/data/ftc-files');
    const files = readdirSync(DATA_DIR).filter(f => f.endsWith('.json')).sort();
    let classified = 0, skipped = 0, errors = 0;
    for (const filename of files) {
      const filePath = path.join(DATA_DIR, filename);
      try {
        const raw = readFileSync(filePath, 'utf-8');
        const data = JSON.parse(raw);
        if (isAlreadyClassified(data)) {
          console.log(`SKIP ${filename} (already classified)`);
          skipped++;
          continue;
        }
        const result = classifyCase(data);
        writeJSONSafe(filePath, result);
        console.log(`OK   ${filename} — topics: ${result.case_info.statutory_topics.join(', ')}`);
        classified++;
      } catch (err) {
        console.error(`ERR  ${filename}: ${err}`);
        errors++;
      }
    }
    console.log(`\nDone: ${classified} classified, ${skipped} skipped, ${errors} errors`);
    ```

    The script must compile type-safe against the interfaces from src/types/ftc.ts. Use explicit relative import with .js extension: `import type { StatutoryTopic, ... } from '../src/types/ftc.js';`

    NOTE: This script implements rule-based classification only (no actual LLM API calls). The rationale: (1) statutory topic extraction from legal_authority is rule-based and reliable; (2) remedy type for most categories is deterministic; (3) practice area detection using title/summary keyword signals covers the majority of cases; (4) the user can manually review and correct edge cases in a spot-check. The user's CONTEXT.md envisions running a Claude Code agent interactively — this script provides the programmatic backbone that can be run as-is for rule-based cases. If practice area quality is insufficient after the first run, a second LLM-assisted pass can target affirmative_obligation provisions specifically.
  </action>
  <verify>Run: npx tsx scripts/classify-provisions.ts --help 2>&1 || npx tsx scripts/classify-provisions.ts 2>&1 | head -20. The script should either print help or begin processing (showing "OK" or "SKIP" lines). It must NOT throw a TypeScript compilation error. Also run: npx tsc --noEmit to confirm zero errors.</verify>
  <done>scripts/classify-provisions.ts exists, runs via `npx tsx`, produces "OK" or "SKIP" output lines per file, and compiles without TypeScript errors. The script handles errors per-file without crashing the full run.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors
2. `npx tsx scripts/classify-provisions.ts 2>&1 | head -5` — shows "OK filename.json — topics: ..." or "SKIP filename.json" for first few files
3. After first file is classified: `cat public/data/ftc-files/01.01_aaron.json | python3 -m json.tool | grep statutory_topics` (or equivalent) — shows the new field present
4. After running on one file: confirm the source file parses as valid JSON (no corruption)
</verification>

<success_criteria>
scripts/classify-provisions.ts:
- Runs via `npx tsx scripts/classify-provisions.ts`
- Processes files sequentially, logs progress per file
- Writes classification tags into source files atomically
- Skips already-classified files (idempotent)
- TypeScript compiles without errors
- No API calls required — pure rule-based classification using legal_authority and provision.category/title/summary fields
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-pipeline/01-02-SUMMARY.md`
</output>
